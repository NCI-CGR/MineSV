#!/usr/bin/env python3

import os

conf = os.environ.get("conf")
configfile: conf

execDir = config['execDir'].rstrip('/') + '/'  # ensure one trailing slash
parentDir = config['outDir'].rstrip('/') + '/'  # ensure one trailing slash
CALLERS = config['callers']
ref = config['refGenome']
refFile = os.path.basename(ref)
refNoExt = os.path.splitext(refFile)[0]
# clusterMode = config['clusterMode']
anMode = config['analysisMode']
bamList = config['inFile']
dataDir = config['inDir'].rstrip('/') + '/'  # ensure one trailing slash
outDir = config['outDir'].rstrip('/') + '/'  # ensure one trailing slash
callAndAnnotate = config['runMode']['callAndAnnotate']
callOnly = config['runMode']['callOnly']
annotateOnly = config['runMode']['annotateOnly']


bamDict = {}
with open(bamList) as f:
    for line in f:
        (pair, tumor, normal) = line.split()
        bamDict[pair] = (dataDir + tumor, dataDir + normal)


def get_tumor_bam(wildcards):
    (tumor, normal) = bamDict[wildcards.sample]
    return tumor


def get_tumor_index(wildcards):
    (tumor, normal) = bamDict[wildcards.sample]
    return tumor + '.bai'


def get_normal_bam(wildcards):
    (tumor, normal) = bamDict[wildcards.sample]
    return normal


def get_normal_index(wildcards):
    (tumor, normal) = bamDict[wildcards.sample]
    return normal + '.bai'



if callOnly: 
    for c in CALLERS:
        include: 'modules/Snakefile_' + c + '_' + anMode
    rule all:
        input:
            # expand(parentDir + 'SV_files_for_annotation_{caller}.txt', caller=CALLERS)
            parentDir + 'SV_files_for_annotation.txt'

    # if this works, put it under the next section too
    rule combine_ann_files:
        input:
            expand(parentDir + 'SV_files_for_annotation_{caller}.txt', caller=CALLERS)
        output:
            parentDir + 'SV_files_for_annotation.txt'
        run:
            inputDict = {}
            for file in input:
                with open(file) as f:
                    for line in f:
                        l = line.split()
                        if l[0] in inputDict:
                            inputDict[l[0]].append(l[1])
                        else:
                            inputDict[l[0]] = [l[1]]
                        print(inputDict)
            with open(str(output), 'w') as out:
                for key, values in inputDict.items(): 
                    out.write('\t'.join([key] + [str(x) for x in values]) + '\n')


elif callAndAnnotate:
    for c in CALLERS:
        include: 'modules/Snakefile_' + c + '_' + anMode
    include: 'modules/Snakefile_compare_and_annotate'
    
    rule all:
        input:
            # parentDir + 'SV_files_for_annotation.txt',
            expand(annOutDir + '{caller}/interchromosomal/{sample}.compare.summary', caller=CALLERS, sample=bamDict.keys()),
            expand(annOutDir + '{caller}/intrachromosomal/{sample}_annotated_comparison', caller=CALLERS, sample=bamDict.keys())

    rule combine_ann_files:
        input:
            expand(parentDir + 'SV_files_for_annotation_{caller}.txt', caller=CALLERS)
        output:
            parentDir + 'SV_files_for_annotation.txt'
        run:
            inputDict = {}
            for file in input:
                with open(file) as f:
                    for line in f:
                        l = line.split()
                        if l[0] in inputDict:
                            inputDict[l[0]].append(l[1])
                        else:
                            inputDict[l[0]] = [l[1]]
                        print(inputDict)
            with open(str(output), 'w') as out:
                for key, values in inputDict.items(): 
                    out.write(' '.join([key] + [str(x) for x in values]) + '\n')

    

# In addition to including rules of another workflow, Snakemake allows to depend on the output of other workflows as sub-workflows. A sub-workflow is executed independently before the current workflow is executed. Thereby, Snakemake ensures that all files the current workflow depends on are created or updated if necessary. This allows to create links between otherwise separate data analyses.

# subworkflow otherworkflow:
#     workdir: "../path/to/otherworkflow"
#     snakefile: "../path/to/otherworkflow/Snakefile"

# rule a:
#     input:  otherworkflow("test.txt")
#     output: ...
#     shell:  ...
# Here, the subworkflow is named “otherworkflow” and it is located in the working directory ../path/to/otherworkflow. The snakefile is in the same directory and called Snakefile. If snakefile is not defined for the subworkflow, it is assumed be located in the workdir location and called Snakefile, hence, above we could have left the snakefile keyword out as well. If workdir is not specified, it is assumed to be the same as the current one. Files that are output from the subworkflow that we depend on are marked with the otherworkflow function (see the input of rule a). This function automatically determines the absolute path to the file (here ../path/to/otherworkflow/test.txt).

# When executing, snakemake first tries to create (or update, if necessary) test.txt (and all other possibly mentioned dependencies) by executing the subworkflow. Then the current workflow is executed. This can also happen recursively, since the subworkflow may have its own subworkflows as well.

elif annotateOnly:
    include: 'modules/Snakefile_compare_and_annotate'
    rule all:
        input:
            expand(annOutDir + '{caller}/interchromosomal/{sample}.compare.summary', caller=CALLERS, sample=inputDict.keys()),
            expand(annOutDir + '{caller}/intrachromosomal/{sample}_annotated_comparison', caller=CALLERS, sample=inputDict.keys())
